import java.util.ArrayList;

public class BinaryHeapPriorityQueue<T> /*implements Comparable<T>*/ {
	
	private static final int DEFAULT_CAPACITY = 10;
	
	private int heap_size;
	private ArrayList<T> A;
	
	public BinaryHeapPriorityQueue() {
		heap_size = 0;
		A = new ArrayList<T>(DEFAULT_CAPACITY);
	}
	
	public BinaryHeapPriorityQueue(int capacity) {
		heap_size = 0;
		A = new ArrayList<T>(capacity);
	}
	
	public BinaryHeapPriorityQueue(T[] items) {
		heap_size = 0;
		A = new ArrayList<T>(items.length);
		for (T item : A) {
			insert(item);
			heap_size++;
		}
	}
	
	public void insert(T key) {
		heap_size = heap_size + 1;
		A.set(heap_size, Integer.MIN_VALUE);
		increaseKey(heap_size, key);
	}
	
	public T ExtractMax() throws Exception {
		if (heap_size < 1)
			throw new Exception("heap underflow");
		T max = A[1];
		A[1] = A[heap_size];
		heap_size = heap_size - 1;
		this.maxHeapify(1);
		return max;
		
	}
	
	public void increaseKey(int i, T key) throws Exception {
		if ((int) key < (int) A[i]) // TODO Fix casting 
			throw new Exception ("new key is smaller than current key");
		this.A[i] = key;
		while (i > 1 && (int) A[parent(i)] < (int) A[i]) { // TODO Fix casting
			T temp = A[i];
			A[i] = A[parent(i)];
			A[parent(i)] = temp;
			
			i = parent(i);
		}
	}
	
	private void maxHeapify(int i) {
		int largest;
		int l = left(i);
		int r = right(i);
		if (l < heap_size && (int) A[l] > (int) A[r]) // TODO Fix casting
			largest = l;
		else largest = i;
		if (r <= heap_size && (int) A[r] > (int) A[largest]) // TODO Fix casting
			largest = r;
		if (largest != i) {
			T temp = A[i];
			A[i] = A[largest];
			A[largest] = temp;
			maxHeapify(largest);
		}
	}
	
	private int left(int i) {
		return 2 * i;
	}
	
	private int right(int i) {
		return 2 * i + 1;
	}
	
	private int parent(int i) {
		return (int) Math.floor(i / 2);
	}
	
	
	public T deleteMin() {
		
	}
	
	public boolean isEmpty() {
		
	}
	
	public void makeEmpty() {
		
	}
	
	private void percolateDown(int hole) {
		
	}
	private void buildHeap() {
		
	}
	
	private void enlargeArray(int newSize) {
		
	}

//	@Override
//	private int compareTo(T item) {
//		if (item instanceof Integer) {
//			if (this < item) {
//				
//			}
//		}
//		return 0;
//	}
}
